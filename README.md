# DesignPatterns

# SimpleFactory(简单工厂模式)
优点
1.隐藏了对象创建的细节，将产品的实例化推迟到子类中实现。

2.客户端基本不用关心使用的是哪个产品，只需要知道用哪个工厂就行了，提供的类型也可以用比较便于识别的字符串。

3.方便添加新的产品子类，每次只需要修改工厂类传递的类型值就行了。

4.遵循了依赖倒转原则。

缺点
1.要求产品子类的类型差不多，使用的方法名都相同，如果类比较多，而所有的类又必须要添加一种方法，则会是非常麻烦的事情。或者是一种类另一种类有几种方法不相同，客户端无法知道是哪一个产品子类，也就无法调用这几个不相同的方法。

所以简单工厂模式一般应用于多种同类型类的情况，将这些类隐藏起来，再提供统一的接口，便于维护和修改。

# Factory(工厂模式)
优点
基本与简单工厂模式一致，多的一点优点就是遵循了开放-封闭原则，使得模式的灵活性更强。

缺点
与简单工厂模式差不多。

基本与简单工厂模式一致，只不过是改进了简单工厂模式中的开放-封闭原则的缺陷，使得模式更具有弹性。将实例化的过程推迟到子类中，由子类来决定实例化哪个。

# AbstractFactory(抽象工厂模式)
优点
1.封装了产品的创建，使得不需要知道具体是哪种产品，只需要知道是哪个工厂就行了。

2.可以支持不同类型的产品，使得模式灵活性更强。

3.可以非常方便的使用一族中间的不同类型的产品。

缺点
1.结构太过臃肿，如果产品类型比较多，或者产品族类比较多，就会非常难于管理。

2.每次如果添加一组产品，那么所有的工厂类都必须添加一个方法，这样违背了开放-封闭原则。所以一般适用于产品组合产品族变化不大的情况。

例如Linux和windows两种操作系统下，有2个挂件A和B，他们在Linux和Windows下面的实现方式不同，Factory1负责产生能在Linux下运行的挂件A和B，Factory2负责产生能在Windows下运行的挂件A和B，这样如果系统环境发生变化了，我们只需要修改工厂就行了。

# Singleton(单例模式：懒汉/饿汉)

优点
1.减少了时间和空间的开销（new实例的开销）。

2.提高了封装性，使得外部不易改动实例。

 

缺点
1.懒汉式是以时间换空间的方式。

2.饿汉式是以空间换时间的方式。

单例模式常常与工厂模式结合使用，因为工厂只需要创建产品实例就可以了，在多线程的环境下也不会造成任何的冲突，因此只需要一个工厂实例就可以了。
